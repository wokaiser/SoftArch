package view.game;

import interfaces.IObserver;

import java.util.*;

import com.google.inject.Guice;
import com.google.inject.Injector;

import model.general.Constances;
import model.playground.Coordinates;
import modules.SettingsModule;
import controller.GameController;

/** 
 * The GameWithTui class supports playing Battleships over a textual user interface.
 * @author Dennis Parlak
 */
public class GameWithTui implements IObserver {
	
	private static final Scanner INPUT = new Scanner(System.in);
	private enum MessageType { Out, Err };
	private GameController controller;
	private int gametype;
	private String player1;
	private String player2;
	
	/**
	 * Creates a GameWithTui Object
	 */
	public GameWithTui(final GameController controller) {
		this.controller = controller;
	}
	
	/**
	 * The loop should be called to keep the tui running, until the game finished.
	 */
	public void loop() {
		selectGameType();
		enterNames();
		controller.newController(Constances.DEFAULT_ROWS, Constances.DEFAULT_COLUMNS, player1, player2, gametype);
		update();
		while (!controller.gameFinished()) {
			shoot();
		}
		output();
	}
	/**
	 * Prints the messsage to stdout
	 * @param message
	 * @param type
	 */
	private void printMessage(String message, MessageType type) {
		if(type == MessageType.Out) {
			System.out.println(message);
		} else {
			System.err.println(message);
		}
	}
	
	/**
	 * Lets the user choose the game type
	 */
	private void selectGameType() {
		printMessage("\nWelcome to BATTLESHIPS !!!\n\n", MessageType.Out);
		while (true) {
			try {
				printMessage("What kind of game would you like to start?", MessageType.Out);
				printMessage("(1) Player vs. Player", MessageType.Out);
				printMessage("(2) Player vs. AI", MessageType.Out);
				gametype = INPUT.nextInt();
				if (GameController.MULTIPLAYER != gametype && GameController.SINGLEPLAYER != gametype) {
					throw new IllegalArgumentException();
				}
				break;
			} catch (InputMismatchException x) {
				printMessage("Invalid input! Only use numbers!", MessageType.Err);
				INPUT.next();
			} catch (IllegalArgumentException x) {
				printMessage("Invalid number entered! Only the given Options are allowed!", MessageType.Err);
			}
		}
	}	
	
	/**
	 * Read in the names of the players from stdin
	 */
	private void enterNames() {
		switch (gametype) {
		case GameController.SINGLEPLAYER:
			printMessage("Please enter your name:", MessageType.Out);
			player1 = INPUT.next();
			player2 = GameController.AI_PLAYER_1;
			break;
		case GameController.MULTIPLAYER:
			printMessage("Player 1, please enter your Name:", MessageType.Out);
			player1 = INPUT.next();
			printMessage("Player 2, please enter your Name:", MessageType.Out);
			player2 = INPUT.next();
			break;
		}
	}	
	
	/**
	 * Actual player shoot to the enemy playground. If the actual player is a AI the
	 * coordinates to shoot will be generated by the AI, otherwise the coordinates
	 * will be readout from stdin.
	 */
	private void shoot() {
		Coordinates target = new Coordinates(controller.getRows(), controller.getColumns());

		if (!controller.isAI()) {
			target = readInCoordinates();
		}
		controller.shoot(target);
	}

	/**
	 * Read in coordinates from stdin for actual active user
	 */
	private Coordinates readInCoordinates() {
		Coordinates target = new Coordinates(controller.getRows(), controller.getColumns());
		int x, y;
		while (true) {
			try {
				printMessage("Please input Coordinates:", MessageType.Out);
				x = INPUT.nextInt();
				y = INPUT.nextInt();
				if (!target.setColumn(x))
				{
					printMessage("Invalid input! Only use numbers that are in the playfield!", MessageType.Err);
					continue;
				}
				if (!target.setRow(y))
				{
					printMessage("Invalid input! Only use numbers that are in the playfield!", MessageType.Err);
					continue;
				}
				break;
			} catch (InputMismatchException z) {
				printMessage("Invalid input! Only use numbers!", MessageType.Err);
				INPUT.next();
			}
		}
		return target;
	}
		
	/**
	 * Output information about the program status from the controller.
	 */
	public void output() {
		if (0 < controller.getStatus().getErrorCount()) {
			printMessage(controller.getStatus().getError(), MessageType.Err);	
		}

		if (0 < controller.getStatus().getTextCount()) {
			printMessage(controller.getStatus().getText(), MessageType.Out);	
		}
		controller.getStatus().clear();
	}
	
	/**
	 * Implementation of update method to be observable.
	 */
	@Override
	public void update() {
		output();
		printMessage("****************************************", MessageType.Out);
		printMessage("Own playground ("+controller.getActivePlayer()+")", MessageType.Out);
		printMessage(controller.getOwnPlaygroundAsString(), MessageType.Out);
		printMessage("Enemy playground ("+controller.getEnemyPlayer()+")", MessageType.Out);
		printMessage(controller.getEnemyPlaygroundAsString(), MessageType.Out);
		printMessage("****************************************", MessageType.Out);
	}
	
	/**
	 * main method.
	 */
	public static void main( String[] args ) {
		Injector inject = Guice.createInjector(new SettingsModule());
		GameController controller = inject.getInstance(GameController.class);
		controller.initController(Constances.DEFAULT_ROWS, Constances.DEFAULT_COLUMNS, "Player 1", GameController.AI_PLAYER_1, GameController.SINGLEPLAYER);
		GameWithTui tui = new GameWithTui(controller);
		controller.addObserver(tui);
		tui.loop();
	}
}

